#!/usr/bin/env python

# SPDX-FileCopyrightText: 2024 Stefano Zacchiroli <zack@upsilon.cc>
# SPDX-License-Identifier: GPL-3.0-or-later

import beancount.loader
import click
import logging
import re

from beancount.core import data
from beancount.parser.printer import print_entry
from dataclasses import dataclass
from typing import Any, Optional


DEFAULT_LEDGER = "current.beancount"
FAKE_TAGS_SEP = ","


@dataclass
class Criteria:
    """Criteria to select matching beancount entries."""

    account: Optional[re.Pattern] = None
    amount: Optional[Any] = None  # TODO: filter on amounts
    currency: Optional[Any] = None  # TODO: filter on currencies
    date: Optional[Any] = None  # TODO: filter on dates
    metadata: Optional[Any] = None  # TODO: filter on key/value metadata
    narration: Optional[re.Pattern] = None
    payee: Optional[re.Pattern] = None
    tag: Optional[re.Pattern] = None
    type_: Optional[Any] = None  # TODO: filter on beancount entry types


def get_accounts(entry: data.Directive) -> set[str]:
    """Extract account names referenced from a beancount directive.

    - For transactions, return the name of all accounts in postings.

    - For directives like open, close, etc. return the singleton name of the
      referenced account.

    """
    accounts = []

    match type(entry):
        case (
            data.Open | data.Close | data.Pad | data.Balance | data.Note | data.Document
        ) if entry.account is not None:
            accounts.append(entry.account)
        case data.Transaction:
            accounts.extend(p.account for p in entry.postings)

    return set(accounts)


def get_tags(entry: data.Directive, fake_tags_key="tags") -> set[str]:
    """Extract all tags applied to a beancount directive.

    Returned tags include:

    - Tags applied globally to the directive.

    - Tags applied locally to a transaction posting, as comma-separated strings in the
      value of the fake_tags_key metadata key. Passing fake_tags_key=None will disable
      looking for these tags.

    """
    tags = []

    if hasattr(entry, "tags"):
        tags.extend(entry.tags)

    if isinstance(entry, data.Transaction) and fake_tags_key is not None:
        for posting in getattr(entry, "postings", []):
            tags.extend(
                tag.strip()
                for tag in posting.meta.get(fake_tags_key, "").split(FAKE_TAGS_SEP)
            )

    return set(tags)


def entry_matches(entry: data.Directive, criteria: Criteria) -> bool:
    """Check if a beancount entry matches stated criteria."""

    predicates = []
    if criteria.account:
        predicates.append(
            lambda e: (any(re.search(criteria.account, a) for a in get_accounts(e)))
        )
    if criteria.narration:
        predicates.append(
            lambda e: (
                hasattr(e, "narration") and re.search(criteria.narration, e.narration)
            )
        )
    if criteria.payee:
        predicates.append(
            lambda e: (hasattr(e, "payee") and re.search(criteria.payee, e.payee))
        )
    if criteria.tag:
        predicates.append(
            lambda e: (any(re.search(criteria.tag, t) for t in get_tags(e)))
        )

    is_match = all(p(entry) for p in predicates)
    return is_match


def build_criteria(ignore_case, account_RE, narration_RE, payee_RE, tag_RE) -> Criteria:
    """Build a Criteria object from command line arguments."""

    re_flags = 0
    if ignore_case:
        re_flags = re.IGNORECASE

    criteria = Criteria()

    if account_RE is not None:
        criteria.account = re.compile(account_RE, flags=re_flags)
    if narration_RE is not None:
        criteria.narration = re.compile(narration_RE, flags=re_flags)
    if payee_RE is not None:
        criteria.payee = re.compile(payee_RE, flags=re_flags)
    if tag_RE is not None:
        criteria.tag = re.compile(tag_RE, flags=re_flags)

    return criteria


@click.argument(
    "filename", type=click.Path(exists=True, dir_okay=False), default=DEFAULT_LEDGER
)
@click.option(
    "-i",
    "--ignore-case/--no-ignore-case",
    "ignore_case",
    default=False,
    show_default=True,
    help="Ignore case distinctions in string matches.",
)
@click.option(
    "--account",
    "-a",
    "account_RE",
    show_default=True,
    help="Only return entries referencing accounts with names matching given regex.",
)
@click.option(
    "--narration",
    "-n",
    "narration_RE",
    show_default=True,
    help="Only return entries whose narrations match given regex.",
)
@click.option(
    "--payee",
    "-p",
    "payee_RE",
    show_default=True,
    help="Only return entries whose payees match given regex.",
)
@click.option(
    "--tag",
    "-t",
    "tag_RE",
    show_default=True,
    help="Only return entries with at least one tag matching this regex. "
    "The tag can be located anywhere.",
)
@click.command()
def main(filename, ignore_case, account_RE, narration_RE, payee_RE, tag_RE):
    # logging.basicConfig(level=logging.DEBUG)  # XXX for debugging purposes
    ledger = beancount.loader.load_file(filename)
    criteria = build_criteria(ignore_case, account_RE, narration_RE, payee_RE, tag_RE)
    logging.debug(f"Search pattern: {criteria}")
    for entry in ledger[0]:
        if entry_matches(entry, criteria):
            print_entry(entry)


if __name__ == "__main__":
    main()
